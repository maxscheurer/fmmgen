from sympy import itermonomials
from .expansions import M, M_shift, L, L_shift, phi_deriv
from sympy.polys.orderings import monomial_key


def generate_mappings(order, symbols, key='grevlex'):
    """
    generate_mappings(order, symbols, key='grevlex'):

    Generates a set of mappings between three-tuples of
    indices denoting monomials and and array indices.
    Returns both the forward and backward maps.

    Inputs:
    order: int
        Maximum monomial order

    symbols, list
     List of sympy.Symbol type objects


    Returns:
    dict:
        Forward mapping from n-tuple to array index.

    dict:
        Reversed version; mapping from array index to
        tuple mapping.

    Example:
    >>> x, y, z = sp.symbols('x y z')
    >>> map, rmap = generate_mappings(1, [x, y, z])
    >>> print(map):
    {(0, 0, 0): 0, (1, 0, 0): 1, (0, 1, 0): 2, (0, 0, 1): 3}
    >>> print(rmap):
    {0: (0, 0, 0), 1: (1, 0, 0), 2: (0, 1, 0), 3: (0, 0, 1)}
    """
    x, y, z = symbols
    monoms = itermonomials([x, y, z], order)
    if key:
        monom_key = monomial_key(key, [z, y, x])
        monoms = sorted(monoms, key=monom_key)

    index_dict = {}
    rindex_dict = {}
    for i, monom in enumerate(monoms):
        d = monom.as_powers_dict()
        n = d[x], d[y], d[z]
        index_dict[n] = i
        rindex_dict[i] = n
    return index_dict, rindex_dict


def generate_M_operators(order, symbols, index_dict):
    """
    generate_M_operators(order, symbols, index_dict):

    Generates multiple operators up to order.

    Input:
    order, int:
        Maximum order of multipole expansion

    symbols, list:
        List of sympy symbol type objects which
        define coordinate labels.

    index_dict:
        Forward mapping dictionary between
        monomials of symbols and array indices,
        generated by generate_mappings or otherwise.

    Output:
    list:
        List of symbolic multipole moments up to order.

    Example:
    >>> order = 2
    >>> x, y, z = sp.symbols('x y z')
    >>> map, _ = generate_mappings(order, [x, y, z])
    >>> generate_M_operators(order, (x, y, z), map)
    [q, -q*x, -q*y, -q*z, q*x**2/2, q*x*y, q*x*z, q*y**2/2, q*y*z, q*z**2/2]
    """
    x, y, z = symbols
    M_operators = []
    for n in index_dict.keys():
        M_operators.append(M(n, symbols))
    return M_operators


def generate_M_shift_operators(order, symbols, index_dict):
    """
    generate_M_shift_operators(order, symbols, index_dict):

    Generates multipole shifting operators up to order.

    Input:
    order, int:
        Maximum order of multipole expansion

    symbols, list:
        List of sympy symbol type objects which define coordinate labels.

    index_dict:
        Forward mapping dictionary between
        monomials of symbols and array indices, generated by generate_mappings
         or otherwise.

    Output:
    list:
        List of symbolic multipole shifting operators up to order.

    Example:
    >>> order = 1
    >>> x, y, z = sp.symbols('x y z')
    >>> map, _ = generate_mappings(order, [x, y, z])
    >>> generate_M_shift_operators(order, (x, y, z), map)
    [M[0, 0], x*M[0, 0] + M[1, 0], y*M[0, 0] + M[2, 0], z*M[0, 0] + M[3, 0]]
    """
    x, y, z = symbols
    M_operators = []
    for n in index_dict.keys():
        M_operators.append(M_shift(n, order, symbols, index_dict))
    return M_operators


def generate_L_operators(order, symbols, index_dict):
    """
    generate_L_operators(order, symbols, index_dict):

    Generates local expansion operators up to given order.

    Input:
    order, int:
        Maximum order of multipole expansion

    symbols, list:
        List of sympy symbol type objects which define coordinate labels.

    index_dict:
        Forward mapping dictionary between
        monomials of symbols and array indices, generated by generate_mappings
        or otherwise.

    Output:
    list:
        List of symbolic local expansion operators up to order.

    Example:
    >>> order = 1
    >>> x, y, z = sp.symbols('x y z')
    >>> map, _ = generate_mappings(order, (x, y, z))
    >>> generate_L_operators(order, (x, y, z), map)
    [M[0, 0]/R - 1.0*x*M[1, 0]/R**3 - 1.0*y*M[2, 0]/R**3 - 1.0*z*M[3, 0]/R**3,
    -1.0*x*M[0, 0]/R**3, -1.0*y*M[0, 0]/R**3, -1.0*z*M[0, 0]/R**3]
    """
    x, y, z = symbols
    L_operators = []
    for n in index_dict.keys():
        L_operators.append(L(n, order, symbols, index_dict))
    return L_operators


def generate_L_shift_operators(order, symbols, index_dict):
    """
    generate_L_shift_operators(order, symbols, index_dict):

    Generates multiple operators up to order.

    Input:
    order, int:
        Maximum order of multipole expansion

    symbols, list:
        List of sympy symbol type objects which
        define coordinate labels.

    index_dict:
        Forward mapping dictionary between
        monomials of symbols and array indices,
        generated by generate_mappings or otherwise.

    Output:
    list:
        List of symbolic local expansion shifting operators up to order.

    Example:
    >>> order = 1
    >>> x, y, z = sp.symbols('x y z')
    >>> map, _ = generate_mappings(order, (x, y, z))
    >>> generate_L_shift_operators(order, (x, y, z), map)
    [x*L[1, 0] + y*L[2, 0] + z*L[3, 0] + L[0, 0], L[1, 0], L[2, 0], L[3, 0]]
    """
    x, y, z = symbols
    L_shift_operators = []
    for n in index_dict.keys():
        L_shift_operators.append(L_shift(n, order, symbols, index_dict))
    return L_shift_operators


def generate_L2P_operators(order, symbols, index_dict):
    """
    generate_L2P_operators(order, symbols, index_dict):

    Generates potential and field calculation operators up to order.

    Input:
    order, int:
        Maximum order of multipole expansion

    symbols, list:
        List of sympy symbol type objects which define coordinate labels.

    index_dict:
        Forward mapping dictionary between monomials of symbols and array
        indices, generated by generate_mappings or otherwise.

    Output:
    list:
        List of symbolic field calculation operators from local expansions up to
        order.

    Example:
    >>> order = 1
    >>> x, y, z = sp.symbols('x y z')
    >>> map, _ = generate_mappings(order, (x, y, z))
    >>> generate_L2P_operators(order, (x, y, z), map)
    [x*L[1, 0] + y*L[2, 0] + z*L[3, 0] + L[0, 0], -L[1, 0], -L[2, 0], -L[3, 0]]
    """
    phi = phi_deriv(order, symbols, index_dict, deriv=(0, 0, 0))
    Fx = -phi_deriv(order, symbols, index_dict, deriv=(1, 0, 0))
    Fy = -phi_deriv(order, symbols, index_dict, deriv=(0, 1, 0))
    Fz = -phi_deriv(order, symbols, index_dict, deriv=(0, 0, 1))
    return [phi, Fx, Fy, Fz]
